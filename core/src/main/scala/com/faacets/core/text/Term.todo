package com.faacets.core
package text

import scala.reflect.{ClassTag, classTag}

import spire.algebra.{Eq, Monoid}
import spire.math.Rational
import spire.syntax.cfor._
import spire.syntax.monoid._
import fastparse.noApi._
import com.faacets.data.Parsable
import com.faacets.data.syntax.all._
import perm._

import net.alasc.finite.Grp
import net.alasc.perms.Perm

sealed trait GenTerm

case class Sym(partyGroup: Grp[Perm]) extends GenTerm

sealed trait Term[+E <: Element] extends GenTerm {
  def element(p: Int): E
  def elementMap: Map[Int, E]
  def elementsFor(nParties: Int): Seq[E]

  def nOutputsAdvice: Map[Int, Map[Int, NOutputs]] =
    (for {
      (p, element) <- elementMap
      advice = element.nOutputsAdvice if advice.nonEmpty
    } yield (p -> advice)).toMap
}

final class TermParsable extends Parsable[Term[Element]] {

  import com.faacets.data.Parsers._
  import White._

  def toText(t: Term[Element]): String = t match {
    case pt: PTerm => "P(" + pt.aSeq.mkString(",") + "|" + pt.xSeq.mkString(",") +")"
    case gt: SGTerm =>
      val sortedElements = gt.sortedElements
      val outs = sortedElements.map(_._2.stringElements._1)
      val ins = sortedElements.map(_._2.stringElements._2)
      "P_" + sortedElements.map(se => Party.prefix(se._1)).mkString +
      "(" + outs.mkString(",") + "|" + ins.mkString(",") + ")"
    case ct: SCTerm =>
      ct.sortedElements.map {
        case (p, element) => Party.prefix(p) + element.toText
      }.mkString("<", " ", ">")
  }

  val phrase = Parsers.term ~ End

}

object Term {

  implicit val parsable: Parsable[Term[Element]] = new TermParsable

  implicit val equ: Eq[Term[Element]] = spire.optional.genericEq.generic[Term[Element]]

}

trait TermCompanion[T <: Term[E], E <: Element] { self =>
  def elementCompanion: ElementCompanion[E]
  def apply(elements: Seq[E]): T
  /*
  def all(scenario: Scenario): IndexedSeq[T] = new IndexedSeq[T] {
    val shape = scenario.primitiveShape(representation)
    val elements: Seq[IndexedSeq[E]] = scenario.parties.map(elementCompanion.all(_))
    val n = scenario.nParties
    def length = shape.size
    def apply(ind: Int): T = {
      val array = new Array[Int](n)
      shape.ind2sub(ind, array)
      val els = Seq.tabulate(n)( p => elements(p).apply(array(p)) )
      self.apply(els)
    }
  }

  def find(scenario: Scenario, term: T): Int = {
    val n = scenario.nParties
    val array = new Array[Int](n)
    cforRange(0 until n) { p =>
      array(p) = elementCompanion.find(scenario.parties(p), term.element(p))
    }
    scenario.primitiveShape(representation).sub2ind(array)
  }*/
}

sealed trait SeqTerm[+E <: Element] extends Term[E] {
  def elements: Seq[E]
  def elementsFor(nParties: Int): Seq[E] =
    if (nParties != elements.size)
      throw new IllegalArgumentException(s"Invalid number of parties $nParties for term $this")
    else
      elements
  def elementMap: Map[Int, E] = elements.zipWithIndex.map(_.swap).toMap

}

sealed trait MapTerm[+E <: Element] extends Term[E] {
  def elementMap: Map[Int, E]
  def marginalElement: E
    def element(p: Int) = elementMap.getOrElse(p, marginalElement)
  def elementsFor(nParties: Int): Seq[E] =
    Seq.tabulate(nParties)( p => elementMap.getOrElse(p, marginalElement) )
  def sortedElements: Seq[(Int, E)] = elementMap.toSeq.sortBy(_._1)
}

case class PTerm(elements: Seq[PElement]) extends Term[PElement] with SeqTerm[PElement] {
  def element(p: Int) = elements(p)
  def aSeq: Seq[Int] = elements.map(_.a)
  def xSeq: Seq[Int] = elements.map(_.x)
}

object PTerm extends TermCompanion[PTerm, PElement] {
  def elementCompanion = PElement
}

sealed trait SGTerm extends Term[SGElement] with MapTerm[SGElement] {
  def marginalElement = GMarginalElement
  def elementMap: Map[Int, SGElement]
}

object SGTerm extends TermCompanion[SGTerm, SGElement] {
  def elementCompanion = SGElement

  def apply(elementMap: Map[Int, SGElement]) = {
    // GMarginalElement is filtered out, only GOutputElement and GInputElement remain
    val outputElements = elementMap.collect { case (p, el: GOutputElement) => (p -> el) }
    val inputElements = elementMap.collect { case (p, el: GInputElement) => (p -> el) }

    (outputElements.size, inputElements.size) match {
      case (0, 0) => GOverallNormTerm
      case (0, _) => GProperNormTerm(inputElements)
      case (_, 0) => GDataTerm(outputElements)
      case (_, _) => GSignalingTerm(outputElements, inputElements)
    }
  }
  def apply(elements: Seq[SGElement]) = apply(elements.zipWithIndex.map(_.swap).toMap)
}

sealed trait NGTerm extends Term[NGElement] with SGTerm with MapTerm[NGElement] {
  def elementMap: Map[Int, NGElement]
}

object NGTerm extends TermCompanion[NGTerm, NGElement] {
  def elementCompanion = NGElement

  def apply(elementMap: Map[Int, NGElement]) = {
    val outputElements = elementMap.collect { case (p, el: GOutputElement) => (p -> el) }
    if (outputElements.size == 0) GOverallNormTerm else GDataTerm(outputElements)
  }
  def apply(elements: Seq[NGElement]) = apply(elements.zipWithIndex.map(_.swap).toMap)
}

case object GOverallNormTerm extends NGTerm with MapTerm[NGElement] {
  def elementMap = Map.empty[Int, NGElement]
}

case class GDataTerm(elementMap: Map[Int, GOutputElement]) extends NGTerm
case class GProperNormTerm(elementMap: Map[Int, GInputElement]) extends SGTerm
case class GSignalingTerm(
  outputMap: Map[Int, GOutputElement],
  inputMap: Map[Int, GInputElement]) extends SGTerm {
  def elementMap = inputMap ++ outputMap
}

sealed trait SCTerm extends Term[SCElement] with MapTerm[SCElement] {
  def marginalElement = CMarginalElement
  def elementMap: Map[Int, SCElement]
}

object SCTerm extends TermCompanion[SCTerm, SCElement] {
  def elementCompanion = SCElement

  def apply(elementMap: Map[Int, SCElement]) = {
    // CMarginalElement is filtered out, only COutputElement and CInputElement remain
    val outputElements = elementMap.collect { case (p, el: COutputElement) => (p -> el) }
    val inputElements = elementMap.collect { case (p, el: CInputElement) => (p -> el) }

    (outputElements.size, inputElements.size) match {
      case (0, 0) => COverallNormTerm
      case (0, _) => CProperNormTerm(inputElements)
      case (_, 0) => CDataTerm(outputElements)
      case (_, _) => CSignalingTerm(outputElements, inputElements)
    }
  }
  def apply(elements: Seq[SCElement]) = apply(elements.zipWithIndex.map(_.swap).toMap)
}

sealed trait NCTerm extends Term[NCElement] with SCTerm with MapTerm[NCElement] {
  def elementMap: Map[Int, NCElement]
}

object NCTerm extends TermCompanion[NCTerm, NCElement] {
  def elementCompanion = NCElement

  def apply(elementMap: Map[Int, NCElement]) = {
    val outputElements = elementMap.collect { case (p, el: COutputElement) => (p -> el) }
    if (outputElements.size == 0) COverallNormTerm else CDataTerm(outputElements)
  }
  def apply(elements: Seq[NCElement]) = apply(elements.zipWithIndex.map(_.swap).toMap)
}

case object COverallNormTerm extends NCTerm {
  def elementMap = Map.empty[Int, NCElement]
}

case class CDataTerm(elementMap: Map[Int, COutputElement]) extends NCTerm
case class CProperNormTerm(elementMap: Map[Int, CInputElement]) extends SCTerm
case class CSignalingTerm(outputMap: Map[Int, COutputElement],
  inputMap: Map[Int, CInputElement]) extends SCTerm {
  def elementMap = outputMap ++ inputMap
}
