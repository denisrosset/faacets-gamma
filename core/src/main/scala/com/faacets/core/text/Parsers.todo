package com.faacets.core
package text

import com.faacets.core.repr.Group
import fastparse.noApi._

object Parsers {

  import com.faacets.data.Parsers._
  import com.faacets.core.Parsers._
  import com.faacets.core.repr.Parsers.group
  import White._

  val index = nonNegativeInt

  val pTerm: P[PTerm] = P( "P" ~ "(" ~ index.rep(min=1,sep=",") ~ "|" ~ index.rep(min=1,sep=",") ~ ")" )
    .filter { case (outputs, inputs) => outputs.size == inputs.size }
    .map { case (outputs, inputs) =>
      val n = outputs.length
      val elements = (outputs zip inputs).map { case (a, x) => PElement(a, x) }
      PTerm(elements)
    }

  sealed trait GOutput
  case object GNormOutput extends GOutput
  case class GScalarOutput(a: Int) extends GOutput

  // outputs are either _ or an index
  val gScalarOutput: P[GScalarOutput] = index.map( GScalarOutput )
  val gNormOutput: P[GNormOutput.type] = "_".!.map( i => GNormOutput )
  val gOutput: P[GOutput] = gScalarOutput | gNormOutput

  sealed trait GInput
  case class GScalarInput(x: Int) extends GInput
  case class GGroupInput(g: Group) extends GInput

  // inputs are either an index or a group
  val gScalarInput: P[GScalarInput] = index.map( GScalarInput )
  val gGroupInput: P[GGroupInput] = P( "[" ~ group ~ "]" ).map( GGroupInput )
  val gInput: P[GInput] = gGroupInput | gScalarInput

  val gParties: P[Seq[Int]] = P( ("P_" | "P") ~ partyIndex.rep )

  def gElement(output: GOutput, input: GInput): Option[SGElement] = (output, input) match {
    case (GNormOutput, GGroupInput(group)) => Some(GInputElement(group))
    case (GScalarOutput(a), GScalarInput(x)) => Some(GOutputElement(a, x))
    case _ => None
  }

  val gTerm: P[SGTerm] = P( gParties ~ "(" ~ gOutput.rep(sep=",") ~ "|" ~ gInput.rep(sep=",") ~ ")" )
      .filter {
        case (parties, outputs, inputs) => parties.size == outputs.size && outputs.size == inputs.size
      }
      .map {
        case (parties, outputs, inputs) => (parties, (outputs zip inputs).map { case (o, i) => gElement(o, i) })
      }
      .filter(_._2.forall(_.isDefined))
      .map { case (parties, elements) => SGTerm((parties zip elements).map { case (p, el) => (p -> el.get) }.toMap) }

  val cInputElement: P[CInputElement] = P( "[" ~ group ~ "]" ).map( CInputElement )

  def binaryCOutputElement(x: Int) = COutputElement(Group.binary, x)

  val cOutputElement: P[COutputElement] = P( index ~ ("^(" ~ group ~ ")").? ).map {
    case (x, Some(g)) => COutputElement(g, x)
    case (x, None) => binaryCOutputElement(x)
  }

  val cElement: P[SCElement] = cOutputElement | cInputElement

  val partyAndCElement: P[(Int, SCElement)] = P( partyIndex ~ cElement )

  val cTerm: P[SCTerm] = P( "<" ~ partyAndCElement.rep ~ ">" )
    .filter( list => list.map(_._1).toSet.size == list.size )
    .map { seq =>
      val map = Map(seq: _*)
      SCTerm(map)
    }

  val term: P[Term[Element]] = cTerm | gTerm | pTerm

}
