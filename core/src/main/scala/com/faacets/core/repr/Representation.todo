package com.faacets.core
package repr

import spire.math.Rational
import spire.util.Opt

import scalin.immutable.Vec

import scalin.immutable.Mat
import scalin.immutable.dense._
import scalin.syntax.all._

trait Conversion[R <: Representation with Singleton, V[_ <: Scenario with Singleton]] {

  def apply(scenario: Scenario, coefficients: Vec[Rational]): V[scenario.type]

}

class ExprConversion[R <: ProbabilityRepresentation with Singleton](partyMatrix: Party => Mat[Rational])
  extends Conversion[R, Expr] {

  def apply(scenario: Scenario, coefficients: Vec[Rational]): Expr[scenario.type] = {
    val vec = ReverseKronHelpers.revKronMatVec(scenario.parties.map(partyMatrix), coefficients)
    Expr(scenario, vec)
  }

}

class CorrConversion[R <: ProbabilityRepresentation with Singleton](partyMatrix: Party => Mat[Rational])
  extends Conversion[R, Corr] {

  def apply(scenario: Scenario, coefficients: Vec[Rational]): Corr[scenario.type] = {
    val vec = ReverseKronHelpers.revKronMatVec(scenario.parties.map(partyMatrix), coefficients)
    Corr(scenario, vec)
  }

}

class LocalModelConversion[R <: LocalModelRepresentation with Singleton](partyMatrix: Party => Mat[Rational])
  extends Conversion[R, LocalModel] {

  def apply(scenario: Scenario, coefficients: Vec[Rational]): LocalModel[scenario.type] = {
    val vec = ReverseKronHelpers.revKronMatVec(scenario.parties.map(partyMatrix), coefficients)
    LocalModel(scenario, vec)
  }

}

final class Represented[R <: Representation with Singleton, V[_ <: Scenario with Singleton], S <: Scenario with Singleton]
  (val scenario: S, val coefficients: Vec[Rational]) {

  def value(implicit conversion: Conversion[R, V]): V[S] = conversion(scenario: S, coefficients)

}

sealed trait Representation {

  def abbrev: String
  def name: String = abbrev + "Representation"
  def shortName: String = abbrev + "Repr"
  def longName: String
  def alternatives: Seq[String]
  def values = (Seq(abbrev, name, shortName, longName) ++ alternatives).map(Representation.normalize)

}

object Representation {

  def normalize(str: String) = str.toLowerCase.replaceAll("-", "").replaceAll(" ", "")

}

sealed trait ProbabilityRepresentation extends Representation { self =>

  def exprMatrix(party: Party): Mat[Rational]

  def corrMatrix(party: Party): Mat[Rational]

  protected def exprCoefficients(expr: Expr[_ <: Scenario with Singleton]): Vec[Rational] =
    ReverseKronHelpers.revKronMatVec(expr.scenario.parties.map(exprMatrix), expr.coefficients)

  protected def corrCoefficients(corr: Corr[_ <: Scenario with Singleton]): Vec[Rational] =
    ReverseKronHelpers.revKronMatVec(corr.scenario.parties.map(corrMatrix), corr.coefficients)

  def fromExprOpt[S <: Scenario with Singleton](expr: Expr[S]): Opt[Represented[self.type, Expr, S]]

  def fromCorrOpt[S <: Scenario with Singleton](corr: Corr[S]): Opt[Represented[self.type, Corr, S]]

  def expr(scenario: Scenario, coefficients: Vec[Rational]): Represented[self.type, Expr, scenario.type] =
    new Represented[self.type, Expr, scenario.type](scenario, coefficients)

  def corr(scenario: Scenario, coefficients: Vec[Rational]): Represented[self.type, Corr, scenario.type] =
    new Represented[self.type, Corr, scenario.type](scenario, coefficients)

}

trait NonSignalingRepresentation extends ProbabilityRepresentation { self =>

  def fromExprOpt[S <: Scenario with Singleton](e: Expr[S]): Opt[Represented[self.type, Expr, S]] =
    if (e.isInNonSignalingSubspace) Opt(expr(e.scenario: S, exprCoefficients(e)))
    else Opt.empty[Represented[self.type, Expr, S]]

  def fromCorrOpt[S <: Scenario with Singleton](c: Corr[S]): Opt[Represented[self.type, Corr, S]] =
    if (c.isInNonSignalingSubspace) Opt(corr(c.scenario: S, corrCoefficients(c)))
    else Opt.empty[Represented[self.type, Corr, S]]

}

trait SignalingRepresentation extends ProbabilityRepresentation { self =>

  def fromExpr[S <: Scenario with Singleton](e: Expr[S]): Represented[self.type, Expr, S] =
    expr(e.scenario: S, exprCoefficients(e))

  def fromCorr[S <: Scenario with Singleton](c: Corr[S]): Represented[self.type, Corr, S] =
    corr(c.scenario: S, corrCoefficients(c))

  def fromExprOpt[S <: Scenario with Singleton](expr: Expr[S]): Opt[Represented[self.type, Expr, S]] = Opt(fromExpr(expr))

  def fromCorrOpt[S <: Scenario with Singleton](corr: Corr[S]): Opt[Represented[self.type, Corr, S]] = Opt(fromCorr(corr))

}

trait LocalModelRepresentation extends Representation { self =>

  def partyMatrix(party: Party): Mat[Rational]

  def localModel(scenario: Scenario, coefficients: Vec[Rational]): Represented[self.type, LocalModel, scenario.type] =
    new Represented[self.type, LocalModel, scenario.type](scenario, coefficients)

  def fromLocalModel[S <: Scenario with Singleton](lm: LocalModel[S]): Represented[self.type, LocalModel, S] = {
    val vec = ReverseKronHelpers.revKronMatVec(lm.scenario.parties.map(partyMatrix), lm.weights)
    localModel(lm.scenario: S, vec)
  }

}

/*

  implicit val Eq: Eq[Representation] = spire.optional.genericEq.generic[Representation]
  implicit object Textable extends Textable[Representation] {
    def toText(r: Representation): String = r.longName
    def fromText(s: String): Either[String, Representation] =
      Representation.representations.find(_.values.contains(normalize(s))) match {
        case Some(value) => Right(value)
        case None => Left(s"Unknown representation $s")
      }
  }
  implicit val RepresentationMerge: Merge[Representation] = Merge.fromEquals[Representation]

*/